## Self-Learning Guide to Software Engineering

### Introduction

Welcome to the "Self-Learning Guide to Software Engineering." This guide is designed to help **individuals** who are passionate about technology, programming, computer science and other related domains. Whether you're a **complete beginner** with no prior coding experience or someone looking to transition into the field, this guide will provide you with a structured path to follow, resources to explore, and tips to succeed in the exciting world of software development.
#### Prerequisites
- Understand the basic concepts of the your operating system (e.g. Windows) and file navigation.
- Know how to set up your development environment with the necessary tools and software.
- Explore the importance of version control systems (e.g., Git) for **collaborative** coding.
- Choose the programming languages and frameworks that align with your goals. See next section.

### Languages
#### Your first language
For someone new to computer programming and looking to start with a programming language. My recommendations might be different from the major. I recommend starting with one of the following beginner-friendly FP(functional programming) languages:
##### Scheme
- Scheme is a programming language that is known for its simplicity and elegance
- Scheme has a simple and **minimalistic** syntax, making it easier for beginners to understand and learn the fundamentals of programming without being overwhelmed by complex syntax rules.
##### Racket
- Racket is a descendant of **Scheme** and is designed for teaching and experimenting with programming. It has a simple syntax and is particularly well-suited for beginners.
- Racket is widely used in education and has a focus on creating programming languages and domain-specific languages.
##### Haskell
- Haskell is a **purely** functional programming language known for its strong type system and elegant, concise syntax. It's a great choice for learning functional programming concepts.

Choosing the right language is important because it significantly influence your learning experience, the ease with which you grasp **fundamental programming concepts** (Like variable, statements, loop, etc), and your ability to pursue specific areas of interest or career paths within the world of computer science and software development.
#### Low-Level languages
Low-level languages are closer to the hardware and provide more control over the computer's resources. They are often used for system programming, embedded systems, and creating operating systems. You should not start with these languages if you are a newer to programming instead you should learn a high level one first (See previous section).

##### C
   - C is often referred to as a "high-level assembly language" due to its low-level features and excellent control over system resources. It's one of the most widely used low-level languages and is a fantastic choice for learning about memory management, pointers, and direct **hardware** interaction. C is foundational for operating systems, embedded systems, and many other low-level applications.

##### Assembly Language
   - Assembly languages are as low-level as you can get without writing binary machine code. Learning assembly language gives you a deep understanding of how a CPU operates, memory management, and low-level system programming. Choose an assembly language for a specific architecture, such as x86 (Intel), ARM (common in mobile devices), or RISC-V.

##### Rust
   - Rust is a more **modern** language that combines low-level control with high-level safety features. It's designed for systems programming and aims to provide **memory safety** (If you don't know why rust is design in such way, please learn C lang first) without **sacrificing performance**. Rust is a great choice for new programmers who want to learn about low-level systems programming while enjoying modern language features.

##### Zig
-  Zig is a relatively new systems programming language designed for **simplicity**, safety, and performance. It combines low-level control with high-level abstractions and aims to address common pitfalls found in C and C++ programming. Zig's focus on memory safety, error handling, and **straightforward** syntax makes it a promising choice for low-level programming enthusiasts.

It's important to note that low-level programming can be challenging, especially for beginners, due to its focus on **manual memory management** and hardware interactions. 
