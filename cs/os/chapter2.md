# Chapter 2 - Batch System
A batch system is a type of operating system that manages the execution of jobs in **batches**. In a batch system, jobs are submitted to the system as a batch, and the system executes them **one after the other** **without** any user interaction.

In a batch system, jobs are typically submitted to a **queue**, where they wait to be executed. The system then selects jobs from the queue and executes them on available resources, such as CPUs or GPUs. Once a job is completed, the system moves on to the next job in the queue. When a job fails, the system should protect the itself (**Privilege**, **level** of access and control that a user has over the system and its resources.)

## Setup
The user folder is used for applications
```sh
git checkout ch2
git clone https://github.com/LearningOS/rCore-Tutorial-Test-2023A.git user 
```

## The user_lib structure
The `#[link_section = ".text.entry"]` attribute specifies that the function should be placed in the `.text.entry` section of the compiled binary.
```rust
#[no_mangle]
#[link_section = ".text.entry"]
pub extern "C" fn _start() -> ! {
    clear_bss();
    // Some code
    exit(main());
}
```

Defines a main function with weak linkage. The #[linkage = "weak"] attribute specifies that the function has weak linkage, which means that it can be **overridden** by a function with the same name in another module.
```rust
#[linkage = "weak"]
#[no_mangle]
fn main(_argc: usize, _argv: &[&str]) -> i32 {
    panic!("Cannot find main!");
}
```

## The memory layout
- Set the physical address to `0x80400000`
- `.text.entry` was put in the start of the program
- Provides sbss and ebss.

## System Call
> note: 
> - The RISC-V architecture has 32 general-purpose registers, labeled `x0` through `x31`. Register `x0` is hardwired to the value zero and cannot be written to. The other 31 registers can be used for any purpose, such as storing data or holding addresses. 
> - `x10`~`x17` maps to `a0`~`a7` (used for passing function arguments and returning function results, caller-callee convention)
> - `x1` maps to `ra` (return address register, or link register `lr`)

When an application running in **user mode** executes an `ecall` instruction, it triggers a **trap** (Exception: Environment call from U-mode) into the operating system kernel, which runs in **privileged mode**.

We added two system calls here:
```rust
// Write file
fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize;
// Exit program
fn sys_exit(xstate: usize) -> !;
```

When system call happens we should put arguments into the proper registers and run the trap.

```rust
pub fn syscall(id: usize, args: [usize; 3]) -> isize {
    let mut ret: isize;
    unsafe {
        core::arch::asm!(
            "ecall",
            inlateout("x10") args[0] => ret,
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id
        );
    }
    ret
}
```

- `a0` saves the return value to `ret`
- `a1` and `a2` are the arguments
- `a7` saves the system call id

## Link to Kernel
We should link the binary file into the kernel. The kernel should own the information about their quantities and addresses.

The `main.rs` file indicates that the asm handling linking is saved in `link_app.S`
```rust
core::arch::global_asm!(include_str!("link_app.S"));
```

The table defined in the `.data` section of the program is labeled `_num_app`. The first entry in the table is a **64-bit integer** that specifies **the number of applications** in the table. The remaining entries are **pointers** to the start and end addresses of each application.
```asm
# link_app.S
    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 7
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_3_start
    .quad app_4_start
    .quad app_5_start
    .quad app_6_start
    .quad app_6_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin "../user/build/bin/ch2b_bad_address.bin"
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin "../user/build/bin/ch2b_bad_instructions.bin"
app_1_end:

    ...

    .section .data
    .global app_6_start
    .global app_6_end
app_6_start:
    .incbin "../user/build/bin/ch2b_power_7.bin"
app_6_end:

```

> note: This file is generated by `build.rs`

## Find and load
In the `batch.rs` we have
```rust
struct AppManager {
    num_app: usize,
    current_app: usize,
    // Start addresses of applications
    app_start: [usize; MAX_APP_NUM + 1],
}
```

The `UPSafeCell` type is used to ensure that the `AppManager` struct can be safely accessed and modified from multiple threads (preventing being recaptured)
```rust
lazy_static! {
    static ref APP_MANAGER: UPSafeCell<AppManager> = unsafe {
        UPSafeCell::new({
            extern "C" {
                // This function returns a pointer to a table that contains the number of applications and the start addresses of each application.
                fn _num_app();
            }
            let num_app_ptr = _num_app as usize as *const usize;
            // read using the read_volatile method to ensure that the value is not optimized away by the compiler
            let num_app = num_app_ptr.read_volatile();
            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];

            // obtain a slice of the start addresses, which is then copied into the app_start array using the copy_from_slice method
            let app_start_raw: &[usize] =
                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1);
            app_start[..=num_app].copy_from_slice(app_start_raw);
            AppManager {
                num_app,
                current_app: 0,
                app_start,
            }
        })
    };
}
```

> note: 
> - The `lazy_static` macro is used to create a lazily initialized static variable, which is initialized on the first access.
> - `UPSafeCell` was defined in `sync`. The `exclusive_access` method gives a mutable reference. If exists more the one references, it will raise an error `already borrowed: BorrowMutError`

Let's move to `load_app` method
```rust
unsafe fn load_app(&self, app_id: usize) {
        if app_id >= self.num_app {
            println!("All applications completed!");
            use crate::board::QEMUExit;
            crate::board::QEMU_EXIT_HANDLE.exit_success();
        }
        println!("[kernel] Loading app_{}", app_id);
        // clear app area
        core::slice::from_raw_parts_mut(APP_BASE_ADDRESS as *mut u8, APP_SIZE_LIMIT).fill(0);
        let app_src = core::slice::from_raw_parts(
            self.app_start[app_id] as *const u8,
            self.app_start[app_id + 1] - self.app_start[app_id],
        );
        let app_dst = core::slice::from_raw_parts_mut(APP_BASE_ADDRESS as *mut u8, app_src.len());
        app_dst.copy_from_slice(app_src);
        // Memory fence about fetching the instruction memory
        // It is guaranteed that a subsequent instruction fetch must
        // observes all previous writes to the instruction memory.
        // Therefore, fence.i must be executed after we have loaded
        // the code of the next app into the instruction memory.
        // See also: riscv non-priv spec chapter 3, 'Zifencei' extension.
        asm!("fence.i");
    }
```

## Privilege switch
Privilege levels allow the operating system to protect critical system resources and prevent unauthorized access or modification.
- init user mode context when launch an application
- handle system call by applications
- kill application when exception takes place and load next application
- handle exit signal and load next application

### Status Registers
The trap handler routine saves the current user mode context, including the program counter and register values, and switches to kernel mode.

CSR (Control and Status Register) is a special purpose register that controls the state of the processor. There are several types of CSRs in the RISC-V architecture (used for Trap into Supervisor Mode)
- `sstatus` : **control** and **report** the status of the processor. (`SPP` bit gives the info about previous privilege)
- `sepc` : store the **program counter** value at the time of an exception or interrupt. It is used to **resume** execution after the exception or interrupt has been handled.
- `scause` : report the cause of an exception or interrupt
- `stval` : additional info to the Trap
- `stvec` : used to store the **address of the trap handler routine** in supervisor mode.


### Hardware controls
- `sstatues`: `SPP` field will be modified into the current privilege of CPU
- `sepc`: set to the next command after the Trap
- `scause/stval`: reason of current Trap and additional info
- CPU will jump to the address in `stvec` and set the current privilege into **S**. Then start the Trap execution.

After Trap the CPU requires a privilege command named `sret` to accomplish its function:
- Set the privilege by `SPP`
- Jump to the command in `sepc` and continue the execution

## User Stack and Kernel Stack 
The kernel stack and user stack are two separate stacks that are used for storing function call frames and local variables in kernel mode and user mode, respectively.

When a system call is made, the processor switches to **kernel mode** and uses the **kernel stack** to store the **context of the interrupted program**.

When Trap happens, the TrapContext should save the physical resource and some CSRs.
```rust
pub struct TrapContext {
    /// general regs[0..31]
    pub x: [usize; 32],
    /// CSR sstatus      
    pub sstatus: Sstatus,
    /// CSR sepc
    pub sepc: usize,
}
```

## Trap Management
When the OS initialized we should modify the `stvec` register to let it point to the entry point.

```rust
pub fn init() {
    extern "C" {
        fn __alltraps();
    }
    unsafe {
        stvec::write(__alltraps as usize, TrapMode::Direct);
    }
}
```

> note: 
> - In **Direct mode**, the stvec register contains the address of the trap handler routine. When a   trap occurs, the processor jumps **directly** to the address stored in stvec to handle the trap. This mode is useful when there is only **one trap handler routine** for all types of traps.
> - Another trap mode is **Vectored mode**, the stvec register contains a **base** address and a **mode bit**. When a trap occurs, the processor uses the mode bit to determine whether to jump to the base address or to an offset specified by the trap cause. This mode is useful when there are multiple trap handler routines for different types of traps.

Here we use a external symbol named `__alltraps`

```asm
.altmacro
.macro SAVE_GP n
    sd x\n, \n*8(sp)
.endm
.macro LOAD_GP n
    ld x\n, \n*8(sp)
.endm
    .section .text
    .globl __alltraps
    .globl __restore
    .align 2 # 4 byte align
__alltraps:
    # The function first sets the stack pointer to the kernel stack by using the csrrw instruction to swap the stack pointer with the sscratch register.
    csrrw sp, sscratch, sp
    # now sp->kernel stack, sscratch->user stack
    # allocate a TrapContext on kernel stack
    addi sp, sp, -34*8
    # save general-purpose registers
    sd x1, 1*8(sp)
    # skip sp(x2), we will save it later
    sd x3, 3*8(sp)
    # skip tp(x4), application does not use it
    # save x5~x31
    .set n, 5
    .rept 27
        SAVE_GP %n
        .set n, n+1
    .endr
    # we can use t0/t1/t2 freely, because they were saved on kernel stack
    csrr t0, sstatus
    csrr t1, sepc
    sd t0, 32*8(sp)
    sd t1, 33*8(sp)
    # read user stack from sscratch and save it on the kernel stack
    csrr t2, sscratch
    sd t2, 2*8(sp)
    # set input argument of trap_handler(cx: &mut TrapContext)
    mv a0, sp
    call trap_handler
```

The `__restore` function is responsible for restoring the context of the interrupted program after the trap has been handled

```asm
__restore:
    # case1: start running app by __restore
    # case2: back to U after handling trap
    # sets the stack pointer to the address of the TrapContext struct on the kernel stack.
    mv sp, a0
    # now sp->kernel stack(after allocated), sscratch->user stack
    # restore sstatus/sepc
    ld t0, 32*8(sp)
    ld t1, 33*8(sp)
    ld t2, 2*8(sp)
    csrw sstatus, t0
    csrw sepc, t1
    csrw sscratch, t2
    # restore general-purpuse registers except sp/tp
    ld x1, 1*8(sp)
    ld x3, 3*8(sp)
    .set n, 5
    .rept 27
        LOAD_GP %n
        .set n, n+1
    .endr
    # release TrapContext on kernel stack
    addi sp, sp, 34*8
    # now sp->kernel stack, sscratch->user stack
    csrrw sp, sscratch, sp
    sret
```

## Trap Handler

```rust
pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read(); // get trap cause
    let stval = stval::read(); // get extra value
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            // This is done to skip over the ECALL instruction and prevent it from being executed again when the program resumes execution after the system call has been completed
            cx.sepc += 4;
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
        Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => {
            println!("[kernel] PageFault in application, kernel killed it.");
            run_next_app();
        }
        Trap::Exception(Exception::IllegalInstruction) => {
            println!("[kernel] IllegalInstruction in application, kernel killed it.");
            run_next_app();
        }
        _ => {
            panic!(
                "Unsupported trap {:?}, stval = {:#x}!",
                scause.cause(),
                stval
            );
        }
    }
    cx
}
```